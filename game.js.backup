const canvas = document.getElementById('gameCanvas');
// Optimization: alpha: false for performance since we draw a full background
const ctx = canvas.getContext('2d', { alpha: false });

// Game State
turnSpeed: 6.5,
    botCount: 60, // INCREASED from 30 for bigger map
        foodCount: 2000, // INCREASED from 1500
            maxPathPoints: 500, // NEW: Cap path points for performance
                colors: [
                    '#FF3366', '#33FF99', '#33CCFF', '#FF9933', '#CC33FF', '#99FF33', '#3366FF', '#FF3333',
                    '#CC00FF', '#00FF66', '#FF0099', '#66FF00', '#00CCFF', '#FFCC00', '#FFFFFF'
                ],
                    fruitEmojis: ['ðŸ°', 'ðŸ©', 'ðŸª', 'ðŸ¬', 'ðŸ­', 'ðŸ«', 'ðŸ§', 'ðŸ¦', 'ðŸ§', 'ðŸ®', 'ðŸ¥ž', 'ðŸ¥¨', 'ðŸ¥', 'ðŸ¥¯', 'ðŸ§€', 'ðŸ‰', 'ðŸ“', 'ðŸ’'],
                        patterns: ['solid'] // SIMPLIFIED: Only solid colors for performance
};

// Input
let mouse = { x: 0, y: 0 };
let mouseDown = false;
let touchId = null;

// --- Classes ---

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    norm() { let m = this.mag(); return m === 0 ? new Vector(0, 0) : new Vector(this.x / m, this.y / m); }
    dist(v) { return Math.sqrt((this.x - v.x) ** 2 + (this.y - v.y) ** 2); }
    copy() { return new Vector(this.x, this.y); }
}

class Food {
    constructor(x, y, value = 1) {
        this.pos = new Vector(x || (Math.random() * gameMapSize * 2 - gameMapSize), y || (Math.random() * gameMapSize * 2 - gameMapSize));
        if (this.pos.mag() > gameMapSize) this.pos = this.pos.norm().mult(gameMapSize - 50);
        this.value = value;
        this.radius = 12 + (value * 2);
        this.emoji = CONFIG.fruitEmojis[Math.floor(Math.random() * CONFIG.fruitEmojis.length)];
        this.rotation = Math.random() * Math.PI * 2;
        this.floatOffset = Math.random() * 100;
    }
    draw(ctx) {
        if (!isInViewport(this.pos, this.radius)) return;
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        let floatY = Math.sin((Date.now() / 500) + this.floatOffset) * 3;
        ctx.translate(0, floatY);
        ctx.rotate(this.rotation);

        ctx.font = `${this.radius * 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 10;
        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
    }
}

class PowerUp {
    constructor(x, y) {
        this.pos = new Vector(x || (Math.random() * gameMapSize * 2 - gameMapSize), y || (Math.random() * gameMapSize * 2 - gameMapSize));
        if (this.pos.mag() > gameMapSize) this.pos = this.pos.norm().mult(gameMapSize - 50);
        let r = Math.random();
        this.multiplier = r < 0.6 ? 2 : (r < 0.9 ? 5 : 10);
        this.radius = 35;
    }
    draw(ctx) {
        if (!isInViewport(this.pos, this.radius)) return;
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        let scale = 1 + Math.sin(Date.now() / 200) * 0.1;
        ctx.scale(scale, scale);

        ctx.shadowBlur = 20;
        ctx.shadowColor = this.multiplier === 2 ? '#f1c40f' : (this.multiplier === 5 ? '#e67e22' : '#e74c3c');

        ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.multiplier === 2 ? '#f1c40f' : (this.multiplier === 5 ? '#e67e22' : '#e74c3c');
        ctx.fill();
        ctx.lineWidth = 4; ctx.strokeStyle = 'white'; ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white'; ctx.font = 'bold 28px Fredoka One';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(`x${this.multiplier}`, 0, 0);
        ctx.restore();
    }
}

class Snake {
    constructor(name, isBot = false, startScore = 100) {
        this.name = name;
        this.isBot = isBot;
        this.pos = new Vector(Math.random() * gameMapSize * 1.8 - gameMapSize * 0.9, Math.random() * gameMapSize * 1.8 - gameMapSize * 0.9);
        this.angle = Math.random() * Math.PI * 2;
        this.targetAngle = this.angle;

        this.score = startScore;
        this.width = this.calculateWidth();
        this.targetWidth = this.width;

        this.pathSpacing = this.width / 2; // Optimized spacing
        this.path = [];

        // Pre-calculate body so it doesn't "stretch" from a dot
        let startLen = this.calculateTargetLength();
        let dir = new Vector(Math.cos(this.angle), Math.sin(this.angle)).mult(-1); // Backwards
        for (let i = 0; i < startLen; i += this.pathSpacing) {
            this.path.push(this.pos.add(dir.mult(i)));
        }

        this.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
        this.color2 = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
        this.pattern = CONFIG.patterns[Math.floor(Math.random() * CONFIG.patterns.length)];

        if (!this.color.startsWith('#')) this.color = '#FF0000';
        if (!this.color2.startsWith('#')) this.color2 = '#00FF00';

        this.dead = false;
        this.multiplier = 1;
        this.multiplierTimer = 0;
    }

    calculateWidth() {
        // Support massive sizes (10 to 1,000,000)
        return Math.min(200, 10 + Math.log10(Math.max(10, this.score)) * 12);
    }

    calculateTargetLength() {
        // Adaptive length based on size
        return Math.min(5000, 100 + this.score * 0.15);
    }

    getPathSpacing() {
        // Adaptive spacing: larger snakes = wider spacing
        return Math.max(this.width / 2, this.width * 0.8);
    }

    update(dt) {
        if (this.dead) return;

        if (this.multiplier > 1) {
            this.multiplierTimer -= dt;
            if (this.multiplierTimer <= 0) this.multiplier = 1;
        }

        // Turning
        let diff = this.targetAngle - this.angle;
        while (diff <= -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;

        // Responsive turning
        let turnRate = CONFIG.turnSpeed * (25 / this.width);
        let turnAmount = turnRate * dt;

        if (Math.abs(diff) < turnAmount) {
            this.angle = this.targetAngle;
        } else {
            this.angle += Math.sign(diff) * turnAmount;
        }

        // Movement & Boost
        let currentSpeed = (this.isBot && this.width > 50) ? CONFIG.baseSpeed * 0.9 : CONFIG.baseSpeed;
        let boosting = false;

        if (!this.isBot && mouseDown) {
            boosting = true;
        } else if (this.isBot && this.wantBoost) {
            boosting = true;
        }

        // Boost Cost
        if (boosting && this.score > 20) {
            currentSpeed = CONFIG.boostSpeed;
            this.score -= dt * 20;
            if (Math.random() < 0.3) {
                foods.push(new Food(this.path[this.path.length - 1].x, this.path[this.path.length - 1].y, 0.5));
            }
        }

        let moveDist = currentSpeed * dt;
        let velocity = new Vector(Math.cos(this.angle), Math.sin(this.angle)).mult(moveDist);
        this.pos = this.pos.add(velocity);

        // Map Boundaries
        if (this.pos.mag() > gameMapSize) {
            this.dead = true;
            spawnParticles(this.pos, 50, this.color);
            dropFood(this);
        }

        // Path Management - Adaptive spacing for performance
        let lastPoint = this.path[0];
        let dist = this.pos.dist(lastPoint);

        // Add new point with adaptive spacing
        let spacing = this.getPathSpacing();
        if (dist > spacing) {
            this.path.unshift(this.pos.copy());

            // Cap path points for performance
            if (this.path.length > CONFIG.maxPathPoints) {
                this.path.length = CONFIG.maxPathPoints;
            }
        }

        // Simplified path pruning for performance
        let targetLen = this.calculateTargetLength();
        let totalLen = 0;

        // Fast length calculation (sample every 5th point)
        for (let i = 0; i < this.path.length - 5; i += 5) {
            totalLen += this.path[i].dist(this.path[i + 5]) * 5;
        }

        // Prune excess points
        while (totalLen > targetLen && this.path.length > 10) {
            this.path.pop();
            totalLen -= this.width; // Approximate
        }

        this.targetWidth = this.calculateWidth();
        this.width += (this.targetWidth - this.width) * dt * 2; // Faster width transitions
    }

    draw(ctx) {
        if (this.dead) return;

        // Aggressive viewport culling
        if (!isInViewport(this.pos, this.width * 3)) {
            return; // Skip completely if head not visible
        }

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = this.width;

        // OPTIMIZED: Simple lines instead of curves (10x faster)
        ctx.beginPath();
        if (this.path.length > 1) {
            ctx.moveTo(this.path[0].x, this.path[0].y);

            // Draw only visible segments
            let step = Math.max(1, Math.floor(this.path.length / 200)); // Sample points
            for (let i = step; i < this.path.length; i += step) {
                // Skip points outside viewport
                if (isInViewport(this.path[i], this.width)) {
                    ctx.lineTo(this.path[i].x, this.path[i].y);
                }
            }
        } else {
            ctx.moveTo(this.pos.x, this.pos.y);
            ctx.lineTo(this.pos.x - 1, this.pos.y);
        }

        // Simplified rendering - no shadows/gradients for performance
        ctx.strokeStyle = this.color;
        ctx.stroke();

        // Simple highlight
        ctx.lineWidth = this.width * 0.25;
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.stroke();

        // Head
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle);

        // Eyes
        let eyeOffset = this.width * 0.35;
        let eyeSize = this.width * 0.25;

        ctx.shadowBlur = 5;
        ctx.shadowColor = 'black';
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(eyeOffset, -eyeOffset, eyeSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeOffset, eyeOffset, eyeSize, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(eyeOffset + eyeSize * 0.2, -eyeOffset, eyeSize * 0.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeOffset + eyeSize * 0.2, eyeOffset, eyeSize * 0.5, 0, Math.PI * 2); ctx.fill();

        // Mouth
        ctx.beginPath();
        ctx.arc(0, 0, this.width * 0.3, 0, Math.PI, false);
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'black';
        ctx.stroke();

        ctx.restore();

        // Name
        if (this.width > 20) {
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(16, this.width * 0.4)}px Nunito`;
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 4;
            ctx.fillText(this.name, this.pos.x, this.pos.y - this.width / 2 - 20);
            ctx.shadowBlur = 0;
        }
    }

    grow(amount) {
        let actualAmount = amount * this.multiplier;
        this.score += actualAmount * 10;
    }
}


class Bot extends Snake {
    constructor() {
        let r = Math.random();
        let score = 100;

        // Balanced Spawn Rates - 50% Small, 40% Medium, 10% Big
        if (r < 0.5) {
            // 50% Small (Score 50-200)
            score = 50 + Math.random() * 150;
        } else if (r < 0.9) {
            // 40% Medium (Score 200-800)
            score = 200 + Math.random() * 600;
        } else {
            // 10% Big (Score 1000-5000)
            score = 1000 + Math.random() * 4000;
        }

        super(getRandomName(), true, score);
        this.changeDirTimer = 0;
        this.wantBoost = false;
        this.boostCooldown = 0;
    }

    update(dt) {
        if (this.dead) return;

        // AI Logic - Optimized for performance
        let lookAheadDist = this.width * 3 + 150;
        let collisionImminent = false;

        // Simplified collision checking (3 angles instead of 5)
        let angles = [0, 0.7, -0.7];
        for (let a of angles) {
            let checkAngle = this.angle + a;
            let checkPos = this.pos.add(new Vector(Math.cos(checkAngle), Math.sin(checkAngle)).mult(lookAheadDist));

            // Map boundary check
            if (checkPos.mag() > gameMapSize - 100) {
                collisionImminent = true;
                let centerDir = new Vector(0, 0).sub(this.pos);
                this.targetAngle = Math.atan2(centerDir.y, centerDir.x);
                break;
            }

            // Check for nearby snakes (optimized)
            let searchRect = {
                x: Math.min(this.pos.x, checkPos.x) - 100,
                y: Math.min(this.pos.y, checkPos.y) - 100,
                w: Math.abs(this.pos.x - checkPos.x) + 200,
                h: Math.abs(this.pos.y - checkPos.y) + 200
            };

            let nearby = spatialHash.retrieve(searchRect);
            for (let other of nearby) {
                if (other === this || other.dead) continue;

                // Optimized collision check - sample fewer points for performance
                let checkStep = Math.max(3, Math.floor(other.path.length / 8));
                for (let i = 0; i < other.path.length; i += checkStep) {
                    if (checkPos.dist(other.path[i]) < other.width / 2 + this.width + 25) {
                        collisionImminent = true;

                        // Sharp dodge
                        if (a === 0) {
                            this.targetAngle += (Math.random() < 0.5 ? 1 : -1) * (Math.PI / 2);
                        } else {
                            this.targetAngle = this.angle - Math.sign(a) * 1.8;
                        }
                        break;
                    }
                }
                if (collisionImminent) break;
            }
            if (collisionImminent) break;
        }

        // Wandering behavior when no danger
        if (!collisionImminent) {
            this.changeDirTimer -= dt;
            if (this.changeDirTimer <= 0) {
                // More dynamic wandering
                this.targetAngle += (Math.random() - 0.5) * Math.PI * 0.8;
                this.changeDirTimer = Math.random() * 1.5 + 0.5;
            }
        }

        // Aggressive boosting behavior
        if (this.boostCooldown > 0) {
            this.boostCooldown -= dt;
        }

        if (this.boostCooldown <= 0) {
            // Boost when danger is near or randomly for aggression
            if (collisionImminent || Math.random() < 0.15) {
                this.wantBoost = true;
                this.boostCooldown = 0.8; // Boost for 0.8 seconds
            } else {
                this.wantBoost = false;
                this.boostCooldown = 0.3; // Check again in 0.3 seconds
            }
        }

        super.update(dt);
    }
}

function init() {
    console.log("Init called");
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupListeners);
    } else {
        setupListeners();
    }
}

function setupListeners() {
    console.log("Setting up listeners");
    resize();
    window.addEventListener('resize', resize);

    // Track input delay
    window.addEventListener('mousemove', e => {
        let now = performance.now();
        inputDelay = now - lastInputTime;
        lastInputTime = now;
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });
    window.addEventListener('mousedown', () => mouseDown = true);
    window.addEventListener('mouseup', () => mouseDown = false);

    const canvas = document.getElementById('gameCanvas');
    if (canvas) {
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            let now = performance.now();
            inputDelay = now - lastInputTime;
            lastInputTime = now;
            touchId = e.changedTouches[0].identifier;
            mouseDown = true;
            updateTouch(e.changedTouches[0]);
        }, { passive: false });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            let now = performance.now();
            inputDelay = now - lastInputTime;
            lastInputTime = now;
            for (let i = 0; i < e.changedTouches.length; i++) if (e.changedTouches[i].identifier === touchId) updateTouch(e.changedTouches[i]);
        }, { passive: false });
        canvas.addEventListener('touchend', e => { e.preventDefault(); mouseDown = false; });
    }

    // Robust Play Button Logic
    const playBtn = document.getElementById('playBtn');
    const restartBtn = document.getElementById('restartBtn');
    const nameInput = document.getElementById('playerName');

    console.log("Play Button found:", playBtn);

    if (playBtn) {
        playBtn.onclick = function () {
            console.log("Play button clicked");
            startGame();
        };
        // Backup listener
        playBtn.addEventListener('click', startGame);
    }

    if (restartBtn) restartBtn.onclick = resetGame;

    if (nameInput) {
        nameInput.onkeypress = function (e) {
            if (e.key === 'Enter') {
                startGame();
            }
        };
    }
}

function updateTouch(touch) { mouse.x = touch.clientX; mouse.y = touch.clientY; }
function resize() {
    const canvas = document.getElementById('gameCanvas');
    if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
}

function startGame() {
    console.log("Starting Game...");
    let inputName = document.getElementById('playerName').value.trim();
    playerName = inputName || "Player";

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const hud = document.getElementById('hud');

    if (startScreen) startScreen.classList.add('hidden');
    if (gameOverScreen) gameOverScreen.classList.add('hidden');
    if (hud) hud.classList.remove('hidden');

    resetGameLogic();
    gameRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function resetGame() {
    const gameOverScreen = document.getElementById('game-over-screen');
    if (gameOverScreen) gameOverScreen.classList.add('hidden');

    resetGameLogic();
    gameRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function resetGameLogic() {
    player = new Snake(playerName, false, 100);
    bots = []; foods = []; powerups = []; particles = [];
    for (let i = 0; i < CONFIG.botCount; i++) bots.push(new Bot());
    for (let i = 0; i < CONFIG.foodCount; i++) foods.push(new Food());
}

function gameLoop(timestamp) {
    if (!gameRunning) return;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    // Ultra Smooth Fix: Cap dt to prevent physics explosions on lag spikes
    if (dt > 0.05) dt = 0.05;

    update(dt);
    draw();
    requestAnimationFrame(gameLoop);
}

function update(dt) {
    spatialHash.clear();
    spatialHash.insert(player);
    bots.forEach(b => { if (!b.dead) spatialHash.insert(b); });

    let cx = canvas.width / 2;
    let cy = canvas.height / 2;
    let dx = mouse.x - cx;
    let dy = mouse.y - cy;

    // Deadzone for jitter
    if (Math.sqrt(dx * dx + dy * dy) > 10) {
        player.targetAngle = Math.atan2(dy, dx);
    }

    player.update(dt);
    bots.forEach(bot => bot.update(dt));

    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.life -= dt * 60;
        p.pos = p.pos.add(p.vel.mult(dt * 60));
        if (p.life <= 0) particles.splice(i, 1);
    }

    checkCollisions();

    // Cleanup dead bots to prevent memory leak
    bots = bots.filter(b => !b.dead);

    if (foods.length < CONFIG.foodCount) foods.push(new Food());
    if (bots.length < CONFIG.botCount) bots.push(new Bot());
    if (Math.random() < 0.02 && powerups.length < 20) powerups.push(new PowerUp());

    document.getElementById('score').innerText = Math.floor(player.score);
    updateLeaderboard();
    updatePerformanceStats();
}

function checkCollisions() {
    let allSnakes = [player, ...bots];

    for (let s of allSnakes) {
        if (s.dead) continue;

        // Food
        for (let i = foods.length - 1; i >= 0; i--) {
            let f = foods[i];
            if (Math.abs(s.pos.x - f.pos.x) > s.width + f.radius) continue;
            if (Math.abs(s.pos.y - f.pos.y) > s.width + f.radius) continue;
            if (s.pos.dist(f.pos) < s.width / 2 + f.radius) {
                s.grow(f.value);
                foods.splice(i, 1);
            }
        }

        // Powerups
        for (let i = powerups.length - 1; i >= 0; i--) {
            let p = powerups[i];
            if (s.pos.dist(p.pos) < s.width / 2 + p.radius) {
                s.multiplier = p.multiplier;
                s.multiplierTimer = 10;
                powerups.splice(i, 1);
            }
        }
    }

    // Snake vs Snake
    for (let s1 of allSnakes) {
        if (s1.dead) continue;
        let nearby = spatialHash.retrieve({ x: s1.pos.x - 100, y: s1.pos.y - 100, w: 200, h: 200 });

        for (let s2 of nearby) {
            if (s1 === s2 || s2.dead) continue;
            let step = Math.max(1, Math.floor(s2.width / 10));
            for (let i = 0; i < s2.path.length; i += step) {
                let p = s2.path[i];
                // Strict hitbox: 0.35 * width (head) + width/2 (body)
                if (s1.pos.dist(p) < s1.width * 0.35 + s2.width / 2) {
                    s1.dead = true;
                    spawnParticles(s1.pos, 50, s1.color);
                    dropFood(s1);
                    break;
                }
            }
            if (s1.dead) break;
        }
    }

    if (player.dead) gameOver();
}

function dropFood(snake) {
    let step = Math.max(1, Math.floor(snake.width / 10));
    for (let i = 0; i < snake.path.length; i += step) {
        let val = Math.max(1, Math.floor(snake.width / 5));
        // Scatter food slightly
        let scatter = new Vector((Math.random() - 0.5) * snake.width, (Math.random() - 0.5) * snake.width);
        let pos = snake.path[i].add(scatter);
        foods.push(new Food(pos.x, pos.y, val));
    }
}

function spawnParticles(pos, count, color) {
    for (let i = 0; i < count; i++) {
        particles.push({
            pos: new Vector(pos.x, pos.y),
            vel: new Vector((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10),
            life: 50,
            color: color
        });
    }
}

function gameOver() {
    gameRunning = false;
    document.getElementById('final-score').innerText = "Score: " + Math.floor(player.score);
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('hud').classList.add('hidden');
}

function isInViewport(pos, margin) {
    let screenX = pos.x - camera.x;
    let screenY = pos.y - camera.y;
    return screenX > -margin && screenX < canvas.width + margin && screenY > -margin && screenY < canvas.height + margin;
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Smooth Camera
    let targetCamX = player.pos.x - canvas.width / 2;
    let targetCamY = player.pos.y - canvas.height / 2;

    camera.x += (targetCamX - camera.x) * 0.1;
    camera.y += (targetCamY - camera.y) * 0.1;

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    drawGrid();

    ctx.strokeStyle = '#ff0055';
    ctx.lineWidth = 50;
    ctx.beginPath();
    ctx.arc(0, 0, gameMapSize, 0, Math.PI * 2);
    ctx.stroke();

    foods.forEach(f => f.draw(ctx));
    powerups.forEach(p => p.draw(ctx));

    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 50;
        ctx.beginPath(); ctx.arc(p.pos.x, p.pos.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
    });

    bots.sort((a, b) => a.score - b.score).forEach(b => b.draw(ctx));
    player.draw(ctx);

    ctx.restore();

    drawMinimap();
}

function drawMinimap() {
    let mapSize = 150;
    let margin = 20;
    let x = canvas.width - mapSize - margin;
    let y = canvas.height - mapSize - margin;
    let scale = mapSize / (gameMapSize * 2);

    ctx.save();
    ctx.translate(x + mapSize / 2, y + mapSize / 2);

    // Background
    ctx.beginPath();
    ctx.arc(0, 0, mapSize / 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Entities
    // Player
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(player.pos.x * scale, player.pos.y * scale, 3, 0, Math.PI * 2);
    ctx.fill();

    // Bots
    bots.forEach(b => {
        if (b.dead) return;
        ctx.fillStyle = b.score > 10000 ? '#ff0055' : '#aaaaaa';
        ctx.beginPath();
        ctx.arc(b.pos.x * scale, b.pos.y * scale, b.score > 10000 ? 3 : 2, 0, Math.PI * 2);
        ctx.fill();
    });

    ctx.restore();
}

function drawGrid() {
    let startX = camera.x - (camera.x % 150) - 150;
    let startY = camera.y - (camera.y % 150) - 150;
    let endX = camera.x + canvas.width + 150;
    let endY = camera.y + canvas.height + 150;

    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    for (let x = startX; x < endX; x += 150) {
        for (let y = startY; y < endY; y += 260) {
            drawHex(x, y, 90);
            drawHex(x + 75, y + 130, 90);
        }
    }
}

function drawHex(x, y, r) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        let angle = 2 * Math.PI / 6 * i;
        let x_i = x + r * Math.cos(angle);
        let y_i = y + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x_i, y_i); else ctx.lineTo(x_i, y_i);
    }
    ctx.closePath();
    ctx.stroke();
}

function updateLeaderboard() {
    let list = document.getElementById('leaderboard-list');
    let all = [player, ...bots].sort((a, b) => b.score - a.score).slice(0, 10);
    list.innerHTML = all.map((p, i) => {
        let rankIcon = '';
        if (i === 0) rankIcon = 'ðŸ¥‡';
        else if (i === 1) rankIcon = 'ðŸ¥ˆ';
        else if (i === 2) rankIcon = 'ðŸ¥‰';

        return `
        <li style="${p === player ? 'color: #ff0055; font-weight:bold;' : ''}">
            <span>${i + 1}. ${p.name} ${rankIcon}</span>
            <span>${Math.floor(p.score)}</span>
        </li>
        `;
    }).join('');
}

function updatePerformanceStats() {
    let now = performance.now();

    // FPS Calculation
    fpsFrames.push(now);
    fpsFrames = fpsFrames.filter(t => now - t < 1000); // Keep last second
    let fps = fpsFrames.length;

    // Update display every 1 second (reduced from 500ms for better performance)
    if (now - lastFpsUpdate > 1000) {
        document.getElementById('fps').innerText = fps;
        document.getElementById('ping').innerText = Math.floor(Math.random() * 5);
        document.getElementById('input-delay').innerText = Math.floor(inputDelay);
        lastFpsUpdate = now;
    }
}

function getRandomName() {
    const names = ["Snake", "Worm", "Python", "Viper", "Cobra", "Slayer", "Venom", "Fang", "Noodle", "Slider", "Rex", "Titan", "Goliath", "Hydra", "Basilisk"];
    return names[Math.floor(Math.random() * names.length)] + Math.floor(Math.random() * 1000);
}

// Failsafe Init
console.log("Script Loaded");
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
} else {
    document.addEventListener('DOMContentLoaded', init);
    window.onload = init;
}
